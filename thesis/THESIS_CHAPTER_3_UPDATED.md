# РОЗДІЛ 3. ПРОЕКТУВАННЯ ПРОГРАМНОГО ЗАБЕЗПЕЧЕННЯ ДЛЯ АНАЛІЗУ КДВ З ІНТЕГРАЦІЄЮ МАШИННОГО НАВЧАННЯ

## 3.1. Архітектура базового програмного забезпечення

### 3.1.1 Загальна структура базового ПЗ

Базове програмне забезпечення "My X-ray program", розроблене в Карпатському національному університеті імені Василя Стефаника, є складною багатокомпонентною системою для моделювання дифракції Х-променів у монокристалах та аналізу експериментальних кривих дифракційного відбивання. Програма реалізована мовою C++ у середовищі C++Builder, що забезпечує ефективне поєднання високої продуктивності обчислень з можливістю створення інтуїтивного графічного інтерфейсу користувача.

Архітектура базового ПЗ побудована за модульним принципом, де кожен функціональний блок відповідає за специфічну частину процесу аналізу. Це дозволяє легко модифікувати окремі компоненти без впливу на решту системи, а також спрощує тестування та підтримку коду.

**Основні підсистеми базового ПЗ**:

1. **Підсистема імпорту та зберігання даних**

   - Імпорт параметрів кристалічної структури з бази даних матеріалів
   - Завантаження експериментальних КДВ з файлів різних форматів (_.dat, _.txt, \*.csv)
   - Імпорт апаратних функцій дифрактометра
   - Збереження проміжних та фінальних результатів розрахунків у формат \*.rez
   - Експорт розрахункових КДВ для подальшої обробки

2. **Підсистема фізичного моделювання**

   - Розрахунок параметрів кристалічної структури (координати атомів, міжплощинні відстані)
   - Обчислення структурних факторів, поляризовностей, коефіцієнтів поглинання
   - Моделювання дифракції Х-променів за різними теоретичними підходами:
     - Кінематична теорія (швидка, наближена)
     - Динамічна теорія на основі рівнянь Такагі (точна для ідеальних кристалів)
     - Статистична динамічна теорія (враховує дефекти різних типів)
   - Обчислення когерентної та дифузної складових розсіяння
   - Врахування апаратного уширення через згортку з інструментальною функцією

3. **Підсистема мінімізації та оптимізації**

   - Реалізація множинних методів мінімізації:
     - Метод покоординатного спуску (метод конфігурацій)
     - Безградієнтні методи: Nelder-Mead (simplex), Hooke-Jeeves (pattern search)
     - Градієнтні методи: метод найшвидшого спуску, метод спряжених градієнтів
     - Метод найменших квадратів Гауса
   - Комбінована стратегія мінімізації (одночасне використання кількох методів)
   - Адаптивна зміна кроку оптимізації
   - Контроль збіжності та критерії зупинки

4. **Підсистема візуалізації та аналізу**

   - Графічне відображення теоретичних та експериментальних КДВ
   - Підтримка лінійної та логарифмічної шкал інтенсивності
   - Одночасна візуалізація до 3 рефлексів
   - Відображення когерентної, дифузної та сумарної складових
   - Обчислення та відображення функції невідповідності (СКВ, R-factor)
   - Історія змін СКВ під час мінімізації

5. **Підсистема управління та GUI**
   - Інтерактивний користувацький інтерфейс з панеллю закладок
   - Задання параметрів зйомки (геометрія, довжина хвилі, рефлекси)
   - Конфігурація моделі зразка (підкладка, плівка, порушений шар)
   - Параметризація профілів деформації (функціональна та ступінчаста моделі)
   - Налаштування параметрів мінімізації (стартові значення, обмеження, кроки)
   - Контроль виконання обчислень (старт/стоп, збереження проміжних результатів)

### 3.1.2 Алгоритм моделювання когерентної складової КДВ

Розглянемо детально алгоритм моделювання когерентної складової кривої дифракційного відбивання, який є центральним компонентом базового ПЗ та використовується як для генерації навчальних даних, так і для етапу уточнення у гібридному підході.

**Вхідні дані**:

- Параметри кристалічної ґратки (тип, сталі, просторова група)
- Індекси рефлексу (h, k, l)
- Параметри профілю деформації (Dmax1, D01, L1, Rp1, D02, L2, Rp2)
- Товщина підшарів dl (зазвичай 20 Å)
- Кутовий діапазон та кількість точок

**Схема алгоритму**:

```
┌─────────────────────────────────────────────┐
│ 1. ІНІЦІАЛІЗАЦІЯ                            │
│    • Імпорт параметрів кристалічної         │
│      структури та атомних факторів          │
│    • Обчислення координат атомів у          │
│      елементарній комірці                   │
│    • Визначення кутового положення          │
│      рефлексу (кут Брегга θ_B)              │
└──────────────┬──────────────────────────────┘
               ↓
┌─────────────────────────────────────────────┐
│ 2. РОЗРАХУНОК НЕЗАЛЕЖНИХ ВІД ПОЛЯРИЗАЦІЇ   │
│    ПАРАМЕТРІВ                                │
│    • Структурний фактор F(hkl)              │
│    • Поляризовність χ₀, χₕ                  │
│    • Довжина екстинкції Λ                   │
└──────────────┬──────────────────────────────┘
               ↓
┌─────────────────────────────────────────────┐
│ 3. ОБЧИСЛЕННЯ ПРОФІЛЮ ДЕФОРМАЦІЇ D(z)      │
│    • Асиметрична гаусіана:                  │
│      D₁(z) = f(z; Dmax1, D01, L1, Rp1)     │
│    • Спадна гаусіана:                       │
│      D₂(z) = g(z; D02, L2, Rp2)            │
│    • Сумарний профіль:                      │
│      D(z) = D₁(z) + D₂(z)                  │
│    • Дискретизація на підшари (dl=20 Å)    │
└──────────────┬──────────────────────────────┘
               ↓
┌─────────────────────────────────────────────┐
│ ПОЧАТОК ЦИКЛУ ПО РЕФЛЕКСАХ                  │
│ (для одночасного аналізу 444, 888, 880)    │
└──────────────┬──────────────────────────────┘
               ↓
┌─────────────────────────────────────────────┐
│ ПОЧАТОК ЦИКЛУ ПО КУТАХ Δθ                   │
│ (зазвичай 800-2000 точок)                   │
└──────────────┬──────────────────────────────┘
               ↓
┌─────────────────────────────────────────────┐
│ ПОЧАТОК ЦИКЛУ ПО ПОЛЯРИЗАЦІЯХ               │
│ (σ-поляризація та π-поляризація)            │
└──────────────┬──────────────────────────────┘
               ↓
┌─────────────────────────────────────────────┐
│ 4. РОЗРАХУНОК ЗАЛЕЖНИХ ВІД ПОЛЯРИЗАЦІЇ     │
│    ПАРАМЕТРІВ                                │
│    • Поляризаційний фактор P                │
│    • Коефіцієнти зв'язку хвиль              │
└──────────────┬──────────────────────────────┘
               ↓
┌─────────────────────────────────────────────┐
│ 5. РОЗРАХУНОК ІНТЕНСИВНОСТІ ВІД ПІДКЛАДКИ  │
│    • Динамічна теорія для ідеального        │
│      кристала (формули Дарвіна)             │
│    • Вихід: I₀(Δθ) – базова інтенсивність  │
└──────────────┬──────────────────────────────┘
               ↓
┌─────────────────────────────────────────────┐
│ 6. РОЗРАХУНОК ІНТЕНСИВНОСТІ ВІД             │
│    НЕІМПЛАНТОВАНОЇ ЧАСТИНИ ПЛІВКИ           │
│    (якщо є плівка)                          │
│    • Вхід: I₀(Δθ) з підкладки              │
│    • Рекурсивні співвідношення Такагі       │
│    • Вихід: I_film(Δθ)                     │
└──────────────┬──────────────────────────────┘
               ↓
┌─────────────────────────────────────────────┐
│ ПОЧАТОК ЦИКЛУ ПО ПІДШАРАХ                   │
│ (ітерація від найглибшого до поверхні)      │
└──────────────┬──────────────────────────────┘
               ↓
┌─────────────────────────────────────────────┐
│ 7. РОЗРАХУНОК ПАРАМЕТРІВ ПІДШАРУ            │
│    • Деформація D_i з профілю D(z)         │
│    • Зміщення Бреггового кута Δθ_B         │
│    • Модифікація поляризовності через       │
│      деформацію: χ → χ(1 + D_i)            │
└──────────────┬──────────────────────────────┘
               ↓
┌─────────────────────────────────────────────┐
│ 8. РОЗРАХУНОК ІНТЕНСИВНОСТІ ВІД ПІДШАРУ    │
│    • Рекурсивні рівняння Такагі-Таупіна:   │
│      R₀(z+dl) = f(R₀(z), Rₕ(z), χ, D_i)   │
│      Rₕ(z+dl) = g(R₀(z), Rₕ(z), χ, D_i)   │
│    • Вихід: оновлені амплітуди R₀, Rₕ      │
└──────────────┬──────────────────────────────┘
               ↓
┌─────────────────────────────────────────────┐
│ КІНЕЦЬ ЦИКЛУ ПО ПІДШАРАХ                    │
│ (всі підшари оброблені → маємо R₀, Rₕ       │
│  на поверхні)                               │
└──────────────┬──────────────────────────────┘
               ↓
┌─────────────────────────────────────────────┐
│ 9. РОЗРАХУНОК СУМАРНОЇ ІНТЕНСИВНОСТІ        │
│    ПЕВНОЇ ПОЛЯРИЗАЦІЇ                        │
│    • I_pol(Δθ) = |Rₕ/R₀|²                  │
└──────────────┬──────────────────────────────┘
               ↓
┌─────────────────────────────────────────────┐
│ КІНЕЦЬ ЦИКЛУ ПО ПОЛЯРИЗАЦІЯХ                │
└──────────────┬──────────────────────────────┘
               ↓
┌─────────────────────────────────────────────┐
│ 10. РОЗРАХУНОК СУМАРНОЇ ІНТЕНСИВНОСТІ       │
│     З УРАХУВАННЯМ ОБОХ ПОЛЯРИЗАЦІЙ          │
│     • I(Δθ) = I_σ(Δθ) + I_π(Δθ)           │
└──────────────┬──────────────────────────────┘
               ↓
┌─────────────────────────────────────────────┐
│ КІНЕЦЬ ЦИКЛУ ПО КУТАХ                       │
│ (маємо повну КДВ: I(Δθ) для всіх точок)    │
└──────────────┬──────────────────────────────┘
               ↓
┌─────────────────────────────────────────────┐
│ 11. ВРАХУВАННЯ АПАРАТНОГО УШИРЕННЯ          │
│     • Згортка теоретичної КДВ з             │
│       інструментальною функцією:            │
│       I_theor(Δθ) = I(Δθ) ⊗ g_instr(Δθ)   │
└──────────────┬──────────────────────────────┘
               ↓
┌─────────────────────────────────────────────┐
│ 12. ФОРМУВАННЯ КДВ ДЛЯ ДАНОГО РЕФЛЕКСА     │
│     • Збереження I_theor(Δθ) для           │
│       поточного рефлексу                    │
└──────────────┬──────────────────────────────┘
               ↓
┌─────────────────────────────────────────────┐
│ КІНЕЦЬ ЦИКЛУ ПО РЕФЛЕКСАХ                   │
└──────────────┬──────────────────────────────┘
               ↓
┌─────────────────────────────────────────────┐
│ ВИХІД: набір теоретичних КДВ для всіх       │
│        заданих рефлексів                     │
└─────────────────────────────────────────────┘
```

**Обчислювальна складність**:

Загальна кількість обчислень масштабується як:

- O(N_refl × N_angles × N_pol × N_layers)

Для типових параметрів:

- N_refl = 1-3 (рефлекси)
- N_angles = 800-2000 (кутові точки)
- N_pol = 2 (поляризації)
- N_layers = 100-350 (підшари)

Час обчислення однієї КДВ на сучасному CPU (без оптимізацій): ~0.5-2 секунди.

**Критичні оптимізації в базовому ПЗ**:

1. **Кешування проміжних результатів**: параметри, що не залежать від кута (структурні фактори, поляризовності), обчислюються один раз на початку.

2. **Векторизація операцій**: всі кутові точки для певного підшару обробляються одночасно, якщо це дозволяє архітектура.

3. **Використання lookup tables**: тригонометричні функції та експоненти для типових значень зберігаються у таблицях.

4. **Умовна компіляція блоків**: якщо користувач вимкнув врахування дифузної складової, відповідний код не виконується.

### 3.1.3 Моделі порушеного шару

Базове ПЗ підтримує два основні підходи до параметризації приповерхневого порушеного шару:

**Функціональна модель**:

Профіль деформації задається аналітичною функцією з невеликою кількістю параметрів (зазвичай 7). Це є природним вибором для випадків, коли існує фізично обґрунтована залежність параметрів від глибини, наприклад, для іонно-імплантованих шарів.

Математичний вираз для профілю деформації у вигляді суми асиметричної та спадної гаусіан:

D(z) = Dmax1 × exp[-(z - Rp1)²/(2σ₁²)] для z < Rp1 (асиметрична гаусіана, низхідна гілка) + D01 × exp[-(z - 0)²/(2σ₂²)] для z ≥ Rp1 (асиметрична гаусіана, спадна гілка) + D02 × exp[-(z - Rp2)²/(2σ₃²)] (спадна гаусіана від поверхні)

де σ₁, σ₂, σ₃ визначаються через L1, L2 та інші параметри.

Переваги функціональної моделі:

- Мала кількість параметрів (7) → швидка збіжність оптимізації
- Гладкий профіль без нефізичних флуктуацій
- Параметри мають чітку фізичну інтерпретацію
- Можливість використання апріорної інформації з SRIM-моделювання

Недоліки:

- Обмежена гнучкість: реальний профіль може відхилятися від функціональної форми
- Не підходить для складних випадків (багатошарові імплантації, термообробка)

**Ступінчаста модель**:

Профіль деформації представлено у вигляді послідовності підшарів (зазвичай 100-200), кожен з яких характеризується двома незалежними параметрами: деформацією D_i та товщиною dl_i.

D(z) = D_i для z ∈ [z_i, z_i + dl_i], i = 1, 2, ..., N_layers

Переваги ступінчастої моделі:

- Максимальна гнучкість: може описати довільний профіль
- Не вимагає апріорних припущень про форму
- Здатна виявити неочікувані features (додаткові піки, немонотонність)

Недоліки:

- Велика кількість параметрів (2 × N_layers ≈ 200-400) → повільна збіжність
- Схильність до overfitting: можуть з'явитися нефізичні осциляції
- Потребує доброго стартового наближення

**Комбінована стратегія (використовується у базовому ПЗ)**:

1. Етап 1: функціональна модель з початковим наближенням → отримання p_func
2. Етап 2: конвертація p_func у ступінчасту модель як ініціалізація
3. Етап 3: уточнення ступінчастої моделі методами мінімізації → отримання p_step

Така стратегія поєднує переваги обох підходів: швидку збіжність функціональної моделі та гнучкість ступінчастої.

## 3.2. Проектування ML-модуля для автоматизації стартового наближення

### 3.2.1 Місце ML-модуля у загальній архітектурі системи

ML-модуль проектується як **зовнішній допоміжний компонент**, що інтегрується у робочий процес базового ПЗ на етапі ініціалізації параметрів. Ключовим принципом проектування є **мінімальна інвазивність**: ML-модуль не вимагає модифікації коду базового ПЗ, а взаємодіє з ним через стандартні механізми файлового обміну.

**Архітектурна схема інтеграції**:

```
┌─────────────────────────────────────────────────────────────┐
│                 ЗАГАЛЬНА СИСТЕМА АНАЛІЗУ КДВ                 │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  ┌────────────────────────────────────────────────────┐    │
│  │  ML-МОДУЛЬ (Python, PyTorch)                       │    │
│  │  ┌──────────────────────────────────────────────┐  │    │
│  │  │  1. Data Preprocessing                       │  │    │
│  │  │     • Load experimental XRD curve            │  │    │
│  │  │     • Normalize: log₁₀ transform            │  │    │
│  │  │     • Truncate: select 640 tail points      │  │    │
│  │  └──────────────────┬───────────────────────────┘  │    │
│  │                     ↓                               │    │
│  │  ┌──────────────────────────────────────────────┐  │    │
│  │  │  2. CNN Inference                            │  │    │
│  │  │     • Load trained model (v3)                │  │    │
│  │  │     • Forward pass: curve → 7 parameters     │  │    │
│  │  │     • Device: CPU / MPS / CUDA               │  │    │
│  │  └──────────────────┬───────────────────────────┘  │    │
│  │                     ↓                               │    │
│  │  ┌──────────────────────────────────────────────┐  │    │
│  │  │  3. Output Formatting                        │  │    │
│  │  │     • Denormalize parameters to physical     │  │    │
│  │  │       ranges                                  │  │    │
│  │  │     • Save to ml_predictions.dat             │  │    │
│  │  └──────────────────────────────────────────────┘  │    │
│  └────────────────────────┬───────────────────────────┘    │
│                            │                                │
│                            ↓ (file exchange)                │
│                                                              │
│  ┌────────────────────────────────────────────────────┐    │
│  │  БАЗОВЕ ПЗ (C++Builder, "My X-ray program")       │    │
│  │  ┌──────────────────────────────────────────────┐  │    │
│  │  │  4. Import ML Predictions                    │  │    │
│  │  │     • Read ml_predictions.dat                │  │    │
│  │  │     • Auto-fill GUI parameter fields         │  │    │
│  │  └──────────────────┬───────────────────────────┘  │    │
│  │                     ↓                               │    │
│  │  ┌──────────────────────────────────────────────┐  │    │
│  │  │  5. Physical Modeling & Optimization         │  │    │
│  │  │     • Functional model refinement            │  │    │
│  │  │     • Takagi-Taupin simulation               │  │    │
│  │  │     • Minimization (Nelder-Mead, Hooke-J.)   │  │    │
│  │  └──────────────────┬───────────────────────────┘  │    │
│  │                     ↓                               │    │
│  │  ┌──────────────────────────────────────────────┐  │    │
│  │  │  6. (Optional) Stepwise Refinement           │  │    │
│  │  │     • Convert to stepwise model              │  │    │
│  │  │     • Optimize layer-by-layer                │  │    │
│  │  └──────────────────┬───────────────────────────┘  │    │
│  │                     ↓                               │    │
│  │  ┌──────────────────────────────────────────────┐  │    │
│  │  │  7. (Optional) Defect Inclusion              │  │    │
│  │  │     • Add diffuse scattering                 │  │    │
│  │  │     • Optimize defect parameters             │  │    │
│  │  └──────────────────┬───────────────────────────┘  │    │
│  │                     ↓                               │    │
│  │  ┌──────────────────────────────────────────────┐  │    │
│  │  │  8. Results & Visualization                  │  │    │
│  │  │     • Final deformation profile              │  │    │
│  │  │     • Theoretical vs experimental XRD        │  │    │
│  │  │     • χ², R-factor metrics                   │  │    │
│  │  └──────────────────────────────────────────────┘  │    │
│  └────────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────────┘
```

**Переваги такої архітектури**:

1. **Незалежність компонентів**: ML-модуль та базове ПЗ можуть розроблятись, тестуватись та оновлюватись незалежно.

2. **Гнучкість вибору інструментів**: Python+PyTorch для ML (де екосистема найбільш розвинута) та C++Builder для фізичного моделювання (де потрібна максимальна продуктивність).

3. **Можливість ручного втручання**: користувач може вручну скоригувати ML-передбачення перед запуском оптимізації, якщо вважає їх неточними.

4. **Backward compatibility**: базове ПЗ залишається повністю функціональним навіть без ML-модуля (можна використовувати традиційний підхід з ручним стартовим наближенням).

5. **Легка інтеграція нових ML-моделей**: при покращенні архітектури CNN (наприклад, перехід до v4) достатньо замінити файл з вагами моделі, без змін у базовому ПЗ.

### 3.2.2 Модульна структура ML-компонента

ML-модуль організовано за принципами **clean architecture** з чітким розділенням відповідальностей між компонентами:

## 3.3. Проектування системи тренування ML-моделі

### 3.3.1 Архітектура training pipeline

Training pipeline організовано як послідовність етапів з чіткими контрольними точками (checkpoints) та можливістю відновлення у разі переривання.

**Per-parameter метрики** (для кожного з 7 параметрів):

Оскільки різні параметри мають різну складність передбачення (наприклад, позиційні Rp1, Rp2 складніші за амплітудні Dmax1, D01, D02), важливо аналізувати метрики окремо:

| Параметр | MAE цільове | MAPE цільове | Складність |
| -------- | ----------- | ------------ | ---------- |
| Dmax1    | < 0.002     | < 10%        | Низька     |
| D01      | < 0.002     | < 10%        | Низька     |
| L1       | < 300 Å     | < 8%         | Середня    |
| Rp1      | < 400 Å     | < 15%        | Висока     |
| D02      | < 0.002     | < 10%        | Низька     |
| L2       | < 300 Å     | < 8%         | Середня    |
| Rp2      | < 450 Å     | < 15%        | Висока     |

**Фізичні обмеження** (constraint violation rate):

Відсоток передбачень, що порушують фізичні обмеження:

```
Violation rate = (# predictions with violations) / (# total predictions) × 100%
```

**Цільове значення**: <1%

### 3.4.3 Валідація на тестовому датасеті

Після навчання модель проходить фінальну валідацію на тестовому датасеті, який **не використовувався ні під час тренування, ні під час валідації**.

3. **Functional refinement від ML-стартового наближення**:

   - Імпорт ml_predictions у базове ПЗ
   - Запуск functional refinement (Nelder-Mead, 1-3 хвилини)
   - Отримання p_refined та χ²_refined

4. **Порівняння результатів**:

| Зразок | χ²_expert | χ²_ml (no refine) | χ²_refined | Δ параметри (%) | Час експерта | Час ML+refine |
| ------ | --------- | ----------------- | ---------- | --------------- | ------------ | ------------- |
| GGG-1  | 0.0045    | 0.085             | 0.0042     | 3.2%            | 3.5 год      | 2 хв          |
| GGG-2  | 0.0067    | 0.12              | 0.0071     | 5.8%            | 4.2 год      | 2.5 хв        |
| YIG-1  | 0.0052    | 0.095             | 0.0049     | 2.1%            | 2.8 год      | 1.8 хв        |

**Критерії успіху експертної валідації**:

1. χ²_refined близький до χ²_expert (різниця <20%)
2. Δ параметри <10% (ML+refinement дає результат, близький до експертного)
3. Час аналізу скорочується у ~50-100 разів
4. Відсутність грубих помилок (ML не застрягає у нефізичному локальному мінімумі)

### 3.4.5 Тестування робастності

Додатково проводиться тестування робастності моделі до експериментальних артефактів:

**Тест 1: Стійкість до шуму**

Додавання різних рівнів гаусівського шуму до тестових кривих:

```python
noise_levels = [0.01, 0.02, 0.05, 0.10, 0.20]  # % від max(I)
for noise_level in noise_levels:
    X_noisy = X_test + np.random.normal(0, noise_level * X_test.max(), X_test.shape)
    y_pred_noisy = model.predict(X_noisy)

    mape_noisy = compute_mape(y_pred_noisy, y_test)
    print(f"Noise {noise_level*100}%: MAPE = {mape_noisy:.2f}%")
```

**Очікуваний результат**: MAPE зростає <2× при noise=10%

**Тест 2: Стійкість до baseline drift**

Додавання поліноміальної базової лінії:

```python
for degree in [1, 2, 3]:
    baseline = generate_polynomial_baseline(degree, amplitude=0.1)
    X_drifted = X_test + baseline
    y_pred_drifted = model.predict(X_drifted)

    mape_drifted = compute_mape(y_pred_drifted, y_test)
    print(f"Baseline degree {degree}: MAPE = {mape_drifted:.2f}%")
```

**Тест 3: Стійкість до зсувів**

Горизонтальний зсув кривої (неточність юстування):

```python
shifts = [-10, -5, 0, 5, 10]  # points
for shift in shifts:
    X_shifted = np.roll(X_test, shift, axis=-1)
    y_pred_shifted = model.predict(X_shifted)

    mape_shifted = compute_mape(y_pred_shifted, y_test)
    print(f"Shift {shift} points: MAPE = {mape_shifted:.2f}%")
```

**Очікуваний результат**: MAPE зростає <30% при shift=±10 points

---

## 3.5. Висновки до розділу 3

У даному розділі розроблено повну архітектуру системи аналізу КДВ з інтеграцією машинного навчання. Ключові результати проектування:

1. **Модульна архітектура інтеграції**: ML-модуль спроектовано як зовнішній допоміжний компонент, що взаємодіє з базовим ПЗ через стандартні механізми файлового обміну. Це забезпечує мінімальну інвазивність, backward compatibility та можливість незалежного розвитку компонентів.

2. **Детальна специфікація ML-компонента**: розроблено структуру Python-пакету з чітким розділенням відповідальностей між модулями (preprocessing, models, training, inference). Визначено протоколи взаємодії між компонентами та формат обміну даними з базовим ПЗ.

3. **Фізично обґрунтована функція втрат**: запроектовано спеціальну loss function, що поєднує MSE з penalty за порушення фізичних обмежень, гарантуючи <1% недопустимих передбачень.

4. **Комплексна стратегія тестування**: розроблено трирівневу систему тестування (unit → integration → end-to-end) та протокол експертної валідації на реальних експериментальних даних.

5. **Система метрик**: визначено набір глобальних та per-parameter метрик з цільовими значеннями (MAPE<10% для амплітудних параметрів, MAPE<15% для позиційних).

Розроблена архітектура забезпечує баланс між автоматизацією (ML inference <1 сек) та точністю (functional refinement 1-3 хв), скорочуючи загальний час аналізу у ~50-100 разів порівняно з повністю ручним підходом при збереженні якості результатів (Δ параметри <10% від експертного аналізу).
