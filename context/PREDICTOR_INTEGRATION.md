# XRD Predictor - C++ Integration Guide

## Огляд

Standalone predictor для визначення параметрів деформації з XRD кривої.

**Максимально просто:**
- ✅ Один `.exe` файл (не потрібен Python!)
- ✅ Текстові файли для обміну даними (не JSON!)
- ✅ Простий subprocess виклик з C++

## Швидкий Старт

### 1. Встановлення PyInstaller

```bash
pip install pyinstaller
```

### 2. Збірка .exe

```bash
python build_predictor.py
```

**Вихід:**
- `dist/predict.exe` - standalone executable (~100 MB)
- Включає PyTorch, модель, всі залежності
- Працює БЕЗ Python!

### 3. Тестування

```bash
# Створи тестову криву
python -c "import numpy as np; np.savetxt('test.txt', np.random.rand(661))"

# Запусти predictor
./dist/predict.exe test.txt result.txt

# Перевір результат
cat result.txt
```

## Формати Файлів

### Вхідний файл (curve.txt)

661 float чисел, кожне на новому рядку:

```
0.000123
0.000245
0.000389
...
(661 total)
```

**ВАЖЛИВО:** Має бути 661 точка (після crop [40:701])!

### Вихідний файл (params.txt)

7 параметрів з назвами:

```
# XRD Deformation Profile Parameters
# Generated by predict.py
#
# Format: <name> <value>
#
Dmax1    0.012345
D01      0.006789
L1       4.400000e-05
Rp1      2.050000e-05
D02      0.018500
L2       3.500000e-05
Rp2      -2.000000e-05
```

## C++ Integration

### Функції (copy-paste у Difuz.cpp)

```cpp
// 1. Зберегти криву у файл
bool saveCurveToFile(const std::vector<double>& curve, const std::string& filepath);

// 2. Запустити predictor
int runPredictor(const std::string& predictorPath,
                 const std::string& inputPath,
                 const std::string& outputPath);

// 3. Прочитати результат
bool loadParamsFromFile(const std::string& filepath, DeformationProfile& params);

// 4. ALL-IN-ONE функція
bool predictDeformationProfile(const std::vector<double>& expCurve,
                                DeformationProfile& predictedParams,
                                const std::string& predictorPath = "./predict.exe");
```

**Повний код:** Див. `cpp_integration_example.cpp`

### Використання у Difuz.cpp

```cpp
void CYourDialog::OnBnClickedPredict() {
    // 1. Отримати експериментальну криву
    std::vector<double> curve(661);
    for (int i = 0; i < 661; i++) {
        curve[i] = R_vseZ[i + 40];  // Crop [40:701]
    }

    // 2. Predict
    DeformationProfile params;
    if (predictDeformationProfile(curve, params, "predict.exe")) {
        // 3. Заповнити GUI поля
        SetDlgItemText(IDC_EDIT_DMAX1, CString(std::to_string(params.Dmax1).c_str()));
        SetDlgItemText(IDC_EDIT_D01, CString(std::to_string(params.D01).c_str()));
        SetDlgItemText(IDC_EDIT_L1, CString(std::to_string(params.L1).c_str()));
        SetDlgItemText(IDC_EDIT_RP1, CString(std::to_string(params.Rp1).c_str()));
        SetDlgItemText(IDC_EDIT_D02, CString(std::to_string(params.D02).c_str()));
        SetDlgItemText(IDC_EDIT_L2, CString(std::to_string(params.L2).c_str()));
        SetDlgItemText(IDC_EDIT_RP2, CString(std::to_string(params.Rp2).c_str()));

        MessageBox("Parameters predicted successfully!", "Success", MB_OK);
    } else {
        MessageBox("Prediction failed!", "Error", MB_OK | MB_ICONERROR);
    }
}
```

## Deployment

### Що треба скопіювати разом з Difuz.exe:

```
YourApp/
├── Difuz.exe
└── predict.exe         ← Тільки це!
```

**Все інше вже всередині predict.exe!**

## Troubleshooting

### Помилка: "Model checkpoint not found"

```bash
# Переконайся що модель включена в збірку
python build_predictor.py
```

Модель автоматично включається в `.exe` під час збірки.

### Помилка: "Expected 661 values, got XXX"

Переконайся що curve має рівно 661 точку:
- Почни з точки 40 (skip GGG peak)
- Закінчи на точці 700
- `R_vseZ[40:701]` в C++

### Predict.exe працює занадто довго

**Перший запуск:** 5-10 секунд (ініціалізація PyTorch)
**Наступні запуски:** 2-3 секунди

Якщо потрібно швидше - розглянути HTTP server варіант (predict.exe запущений постійно).

### Predict.exe не запускається на іншому комп'ютері

**Причина:** Збірка на macOS/Linux не працює на Windows.

**Рішення:**
1. Збудувати на цільовій платформі:
   ```bash
   # На Windows
   python build_predictor.py
   ```

2. Або використати cross-compilation (складно)

## Продуктивність

| Метрика            | Значення        |
|--------------------|-----------------|
| Розмір .exe        | ~100 MB         |
| Startup time       | 5-10 sec (перший раз) |
| Prediction time    | 2-3 sec         |
| Memory usage       | ~200 MB         |

**Оптимізація (якщо потрібно швидше):**
- Запустити predict.exe як background service
- C++ посилає запити через stdin/stdout
- Уникає startup overhead кожного разу

## Оновлення Моделі

Щоб оновити модель:

1. Натренувати нову модель
2. Перезібрати .exe:
   ```bash
   python build_predictor.py
   ```
3. Замінити `predict.exe` у deployment

**Не потрібно перекомпілювати Difuz.exe!**

## Альтернативи

Якщо subprocess підхід не підходить:

1. **HTTP Server** - predict.exe як background service, C++ через REST API
2. **LibTorch** - PyTorch C++ API, швидше але складніша інтеграція
3. **ONNX Runtime** - export model to ONNX, use ONNX Runtime C++ API

Поточний підхід (subprocess + .exe) - найпростіший і працює чудово для GUI застосунків.

## Приклади

### Python (для тестування)

```python
# Create test curve
import numpy as np
curve = np.random.rand(661) * 1e-3 + 1e-5
np.savetxt('curve.txt', curve)

# Run predictor
import subprocess
subprocess.run(['./predict.exe', 'curve.txt', 'params.txt'])

# Read result
with open('params.txt') as f:
    print(f.read())
```

### C++ (повний приклад)

Див. `cpp_integration_example.cpp` для повного робочого коду.

Компіляція:
```bash
g++ -std=c++11 cpp_integration_example.cpp -o test
./test
```

## Підтримка

**Файли:**
- `predict.py` - Python prediction script
- `build_predictor.py` - Build .exe script
- `cpp_integration_example.cpp` - C++ integration example
- `PREDICTOR_INTEGRATION.md` - Ця документація

**Контакт:** Денис (master-project-light)
